package com.ust.retail.store.pim.service.report;

import com.ust.retail.store.bistro.dto.recipes.LoadUpcAddOnDTO;
import com.ust.retail.store.bistro.repository.recipes.RecipeRepository;
import com.ust.retail.store.bistro.repository.wastage.WastageRepository;
import com.ust.retail.store.bistro.service.recipes.RecipeAddonService;
import com.ust.retail.store.bistro.service.recipes.RecipeService;
import com.ust.retail.store.pim.common.catalogs.PoStatusCatalog;
import com.ust.retail.store.pim.common.catalogs.ProductTypeCatalog;
import com.ust.retail.store.pim.common.catalogs.UpcMasterTypeCatalog;
import com.ust.retail.store.pim.common.catalogs.VendorContactTypeCatalog;
import com.ust.retail.store.pim.dto.catalog.StoreNumberDTO;
import com.ust.retail.store.pim.dto.report.*;
import com.ust.retail.store.pim.dto.upcmaster.StorePriceDTO;
import com.ust.retail.store.pim.dto.upcmaster.UpcMasterDTO;
import com.ust.retail.store.pim.dto.upcmaster.UpcSellingChannelDTO;
import com.ust.retail.store.pim.engine.inventory.BistroTossingInventory;
import com.ust.retail.store.pim.engine.inventory.InventoryEngine;
import com.ust.retail.store.pim.engine.inventory.VendorCredits;
import com.ust.retail.store.pim.model.inventory.InventoryHistoryModel;
import com.ust.retail.store.pim.repository.inventory.InventoryHistoryRepository;
import com.ust.retail.store.pim.repository.inventory.InventoryProductReturnRepository;
import com.ust.retail.store.pim.repository.inventory.PoReceiveDetailRepository;
import com.ust.retail.store.pim.repository.puchaseorder.PurchaseOrderRepository;
import com.ust.retail.store.pim.repository.upcmaster.UpcMasterRepository;
import com.ust.retail.store.pim.service.catalog.StoreNumberService;
import com.ust.retail.store.pim.util.DateUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.data.domain.Page;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.stream.Collectors;

@Service
@Slf4j
public class ReportService {
	private final SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd");
	private final PurchaseOrderRepository purchaseOrderRepository;
	private final PoReceiveDetailRepository poReceiveDetailRepository;
	private final InventoryProductReturnRepository inventoryProductReturnRepository;
	private final InventoryHistoryRepository inventoryHistoryRepository;
	private final UpcMasterRepository upcMasterRepository;
	private final WastageRepository wastageRepository;
	private final RecipeRepository recipeRepository;
	private final RecipeService recipeService;
	private final RecipeAddonService recipeAddonService;
	private final StoreNumberService storeNumberService;

	public ReportService(PurchaseOrderRepository purchaseOrderRepository,
						 PoReceiveDetailRepository poReceiveDetailRepository,
						 InventoryProductReturnRepository inventoryProductReturnRepository,
						 InventoryHistoryRepository inventoryHistoryRepository,
						 UpcMasterRepository upcMasterRepository,
						 WastageRepository wastageRepository,
						 RecipeRepository recipeRepository,
						 RecipeService recipeService,
						 RecipeAddonService recipeAddonService, StoreNumberService storeNumberService) {
		this.purchaseOrderRepository = purchaseOrderRepository;
		this.poReceiveDetailRepository = poReceiveDetailRepository;
		this.inventoryProductReturnRepository = inventoryProductReturnRepository;
		this.inventoryHistoryRepository = inventoryHistoryRepository;
		this.upcMasterRepository = upcMasterRepository;
		this.wastageRepository = wastageRepository;
		this.recipeRepository = recipeRepository;
		this.recipeService = recipeService;
		this.recipeAddonService = recipeAddonService;
		this.storeNumberService = storeNumberService;
	}

	public ByteArrayResource getGeneratedPurchaseOrdersReport(Date startDate, Date endDate) {
		StringBuilder content = new StringBuilder();
		content.append("PO#,Vendor code,Vendor name,Store number,Autogenerated,Created by,Creation date,Status,Sent date,Total cost,Discount,Applied vendor credit,ETA")
				.append(System.lineSeparator());

		String results = purchaseOrderRepository.getGeneratedPurchaseOrdersReport(
						DateUtils.atStartOfDay(startDate),
						DateUtils.atEndOfDay(endDate)).stream()
				.map(po -> String.format("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
						StringUtils.wrap(po.getPurchaseOrderNum(), '"'),
						StringUtils.wrap(po.getVendorMaster().getVendorCode(), '"'),
						StringUtils.wrap(po.getVendorMaster().getVendorName(), '"'),
						StringUtils.wrap(po.getStoreNumber().getStoreName(), '"'),
						StringUtils.wrap(po.isAutogenerated() ? "YES" : "NO", '"'),
						StringUtils.wrap(po.getUserCreate().getNameDesc(), '"'),
						StringUtils.wrap(dateFormatter.format(po.getCreatedAt()), '"'),
						StringUtils.wrap(po.getStatus().getCatalogOptions(), '"'),
						StringUtils.wrap(Optional.ofNullable(po.getSentAt()).map(dateFormatter::format).orElse(""), '"'),
						StringUtils.wrap(numberToString(po.getTotalCost()), '"'),
						StringUtils.wrap(numberToString(po.getDiscount()), '"'),
						StringUtils.wrap(numberToString(po.getAppliedVendorCredit()), '"'),
						StringUtils.wrap(dateFormatter.format(po.getEta()), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		content.append(results);

		return new ByteArrayResource(content.toString().getBytes(StandardCharsets.UTF_8));
	}

	public ByteArrayResource getReceivingReport(Date startDate, Date endDate) {
		StringBuilder content = new StringBuilder();
		content.append("PO#,Reception date,Status,UPC,Product,Req. Qty,Cases,Pallets,Rec. Qty,Problems")
				.append(System.lineSeparator());

		String results = poReceiveDetailRepository.getReceivedReport(
						DateUtils.atStartOfDay(startDate),
						DateUtils.atEndOfDay(endDate)).stream()
				.map(detail -> String.format("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
						StringUtils.wrap(detail.getPurchaseOrderDetail().getPurchaseOrder().getPurchaseOrderNum(), '"'),
						StringUtils.wrap(dateFormatter.format(detail.getCreatedAt()), '"'),
						StringUtils.wrap(detail.getPurchaseOrderDetail().getItemStatus().getCatalogOptions(), '"'),
						StringUtils.wrap(detail.getPurchaseOrderDetail().getUpcMaster().getPrincipalUpc(), '"'),
						StringUtils.wrap(detail.getPurchaseOrderDetail().getUpcMaster().getProductName(), '"'),
						StringUtils.wrap(numberToString(detail.getPurchaseOrderDetail().getTotalAmount()), '"'),
						StringUtils.wrap(numberToString(detail.getPurchaseOrderDetail().getCaseNum()), '"'),
						StringUtils.wrap(numberToString(detail.getPurchaseOrderDetail().getPalletNum()), '"'),
						StringUtils.wrap(numberToString(detail.getReceivedQty()), '"'),
						StringUtils.wrap(
								detail.getReceptionWarnings().stream()
										.map(rw -> String.format("%s: %s", rw.getPk().getWarningReason().getCatalogOptions(), rw.getQty()))
										.collect(Collectors.joining(System.lineSeparator())),
								'"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		content.append(results);

		return new ByteArrayResource(content.toString().getBytes(StandardCharsets.UTF_8));
	}

	public ByteArrayResource getReturnsReport(Date startDate, Date endDate) {
		StringBuilder content = new StringBuilder();
		content.append("UPC,Product name,Store Area,Qty,Reason,Vendor Code,Vendor Name,Credits,Status,Date")
				.append(System.lineSeparator());

		String results = inventoryProductReturnRepository.getReturnsReport(
						DateUtils.atStartOfDay(startDate),
						DateUtils.atEndOfDay(endDate),
						VendorCredits.OPERATION_MODULE).stream()
				.map(tuple -> String.format("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
						StringUtils.wrap(tuple.get(0, String.class), '"'),
						StringUtils.wrap(tuple.get(1, String.class), '"'),
						StringUtils.wrap(tuple.get(2, String.class), '"'),
						StringUtils.wrap(numberToString(tuple.get(3, Double.class)), '"'),
						StringUtils.wrap(tuple.get(4, String.class), '"'),
						StringUtils.wrap(Optional.ofNullable(tuple.get(5, String.class)).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(tuple.get(6, String.class)).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(tuple.get(7, Double.class)).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(tuple.get(8, String.class), '"'),
						StringUtils.wrap(dateFormatter.format(tuple.get(9, Date.class)), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		content.append(results);

		return new ByteArrayResource(content.toString().getBytes(StandardCharsets.UTF_8));
	}

	public ByteArrayResource getInventoryMovementReport(Date startDate, Date endDate) {
		StringBuilder content = new StringBuilder();
		content.append("Date,User,Store Area,UPC,Product,Module,Operation,Authorization,Initial Qty,Operation Qty,Final Qty")
				.append(System.lineSeparator());

		String results = inventoryHistoryRepository.getInventoryMovementReport(
						DateUtils.atStartOfDay(startDate),
						DateUtils.atEndOfDay(endDate)).stream()
				.map(history -> String.format("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s",
						StringUtils.wrap(dateFormatter.format(history.getCreatedAt()), '"'),
						StringUtils.wrap(history.getUserCreate().getNameDesc(), '"'),
						StringUtils.wrap(history.getInventory().getStoreLocation().getStoreLocationName(), '"'),
						StringUtils.wrap(history.getInventory().getUpcMaster().getPrincipalUpc(), '"'),
						StringUtils.wrap(history.getInventory().getUpcMaster().getProductName(), '"'),
						StringUtils.wrap(history.getOperationModule().getCatalogOptions(), '"'),
						StringUtils.wrap(history.getOperationType().getCatalogOptions(), '"'),
						StringUtils.wrap(history.getAuthorizationStatus().getCatalogOptions(), '"'),
						StringUtils.wrap(numberToString(history.getPreviewsQty()), '"'),
						StringUtils.wrap(numberToString(history.getOperationQty()), '"'),
						StringUtils.wrap(numberToString(history.getFinalQty()), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		content.append(results);

		return new ByteArrayResource(content.toString().getBytes(StandardCharsets.UTF_8));
	}

	public ByteArrayResource getUnsoldProductReport(Date startDate, Date endDate) {
		StringBuilder content = new StringBuilder();
		content.append("Date,User,UPC,Product,Initial Qty,Tossed,Final Qty")
				.append(System.lineSeparator());

		List<InventoryHistoryModel> result = inventoryHistoryRepository.getUnsoldProductReport(
				DateUtils.atStartOfDay(startDate),
				DateUtils.atEndOfDay(endDate),
				BistroTossingInventory.OPERATION_MODULE,
				InventoryEngine.OPERATION_TYPE_TOSSING);
		String results = result.stream()
				.map(history -> String.format("%s,%s,%s,%s,%s,%s,%s",
						StringUtils.wrap(dateFormatter.format(history.getCreatedAt()), '"'),
						StringUtils.wrap(history.getUserCreate().getNameDesc(), '"'),
						StringUtils.wrap(history.getInventory().getUpcMaster().getPrincipalUpc(), '"'),
						StringUtils.wrap(history.getInventory().getUpcMaster().getProductName(), '"'),
						StringUtils.wrap(numberToString(history.getPreviewsQty()), '"'),
						StringUtils.wrap(numberToString(history.getOperationQty()), '"'),
						StringUtils.wrap(numberToString(history.getFinalQty()), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		content.append(results);

		return new ByteArrayResource(content.toString().getBytes(StandardCharsets.UTF_8));
	}

	public ByteArrayResource getProductionWasteReport(Date startDate, Date endDate) {
		StringBuilder content = new StringBuilder();
		content.append("Date,User,UPC,Recipe,Whole dish,Ingredient UPC,Ingredient Name,Amount,UOM")
				.append(System.lineSeparator());

		String results = wastageRepository.getProductionWasteReport(
						DateUtils.atStartOfDay(startDate),
						DateUtils.atEndOfDay(endDate)).stream()
				.map(tuple -> String.format("%s,%s,%s,%s,%s,%s,%s,%s,%s",
						StringUtils.wrap(dateFormatter.format(tuple.get(0, Date.class)), '"'),
						StringUtils.wrap(tuple.get(1, String.class), '"'),
						StringUtils.wrap(tuple.get(2, String.class), '"'),
						StringUtils.wrap(tuple.get(3, String.class), '"'),
						StringUtils.wrap(tuple.get(4, Boolean.class) ? "YES" : "NO", '"'),
						StringUtils.wrap(Optional.ofNullable(tuple.get(5, String.class)).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(tuple.get(6, String.class)).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(tuple.get(7, Double.class)).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(tuple.get(8, String.class)).orElse(""), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		content.append(results);

		return new ByteArrayResource(content.toString().getBytes(StandardCharsets.UTF_8));
	}

	public FileSystemResource getUpcCsvDumpForExport(Long storeNumberId) {
		StringBuilder contentBuilder = new StringBuilder();
		String[] headers = {
				"UPC",
				"SKU",
				"Product name",
				"Product Item",
				"Product Group",
				"Product Category",
				"Product Subcategory",
				"Brand",
				"Status (ACTIVE / INACTIVE)",
				"Product Description",
				"Product Image (Yes or No)",
				"Store Section",
				"Height",
				"Width",
				"Depth",
				"Content per Unit",
				"Content per Unit UOM",
				"Country of Origin",
				"Inventory Unit",
				"Sales Price (USD)",
				"Tax %",
				"Shelf Life WH",
				"Shelf Life Shipment",
				"Shelf Life Customer",
				"Planogram Location",
				"Stock min",
				"Exp Date required (True-1/False-0)",
				"Age Restricted (True-1/False-0)",
				"VC Trained (True-1/False-0)",
				"Vendor Name",
				"Vendor Email",
				"Supplier Price - CASE",
				"Supplier Price - UNIT",
				"MOQ (Units)",
				"Units per case",
				"Case UPC",
				"Case Weight (lbs)",
				"Case Length",
				"Case Height",
				"Case Width",
				"Cases per pallet",
				"Pallet Weight (lbs)",
				"Pallet Length",
				"Pallet Height",
				"Pallet Width",
				"Inventory on hand",
				"Additional Fees"};
		String header = Arrays.stream(headers)
				.map(s -> StringUtils.wrap(s, '"'))
				.collect(Collectors.joining(","));

		contentBuilder.append(header)
				.append(System.lineSeparator());

		String results = getUpcCsvDump(storeNumberId).stream()
				.map(upcRecord -> String.format(StringUtils.repeat("%s", ",", headers.length),
						StringUtils.wrap(StringUtils.prependIfMissing(upcRecord.getUpc(), "'"), '"'),
						StringUtils.wrap(upcRecord.getSku(), '"'),
						StringUtils.wrap(upcRecord.getProductName(), '"'),
						StringUtils.wrap(upcRecord.getProductItem(), '"'),
						StringUtils.wrap(upcRecord.getProductGroup(), '"'),
						StringUtils.wrap(upcRecord.getProductCategory(), '"'),
						StringUtils.wrap(upcRecord.getProductSubcategory(), '"'),
						StringUtils.wrap(upcRecord.getBrand(), '"'),
						StringUtils.wrap(upcRecord.getStatus(), '"'),
						StringUtils.wrap(upcRecord.getProductDescription(), '"'),
						StringUtils.wrap(upcRecord.isHasImage() ? "Yes" : "No", '"'),
						StringUtils.wrap(upcRecord.getStoreSection(), '"'),
						StringUtils.wrap(numberToString(upcRecord.getHeight()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getWidth()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getDepth()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getContentPerUnit()), '"'),
						StringUtils.wrap(upcRecord.getContentPerUnitUom(), '"'),
						StringUtils.wrap(upcRecord.getCountryOfOrigin(), '"'),
						StringUtils.wrap(upcRecord.getInventoryUnit(), '"'),
						StringUtils.wrap(numberToString(upcRecord.getSalePrice()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getTaxPercentage()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getShelfLifeWh()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getShelfLifeShipment()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getShelfLifeCustomer()), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getPlanogramLocation()).orElse(""), '"'),
						StringUtils.wrap(numberToString(upcRecord.getStockMin()), '"'),
						StringUtils.wrap(upcRecord.isExpirationDateRequired() ? "1" : "0", '"'),
						StringUtils.wrap(upcRecord.isAgeRestricted() ? "1" : "0", '"'),
						StringUtils.wrap(upcRecord.isImageTrained() ? "1" : "0", '"'),
						StringUtils.wrap(upcRecord.getVendorName(), '"'),
						StringUtils.wrap(upcRecord.getVendorEmail(), '"'),
						StringUtils.wrap(numberToString(upcRecord.getSupplierPriceCase()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getSupplierPriceUnit()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getVendorMoq()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getUnitsPerCase()), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getCaseUpc()).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getCaseWeight()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getCaseLength()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getCaseHeight()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getCaseWidth()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(numberToString(upcRecord.getCasesPerPallet()), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getPalletWeight()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getPalletLength()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getPalletHeight()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getPalletWidth()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(numberToString(upcRecord.getInventoryOnHand()), '"'),
						StringUtils.wrap(upcRecord.getAdditionalFees().stream()
								.map(f -> String.format("%s: %s", f.getFeeName(), f.getPrice()))
								.collect(Collectors.joining(" | ")), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		contentBuilder.append(results);

		String fileName = String.format("upc_master_data_sn_%d_%tF.csv", storeNumberId, new Date());
		return new FileSystemResource(getWrittenFilePath(fileName, contentBuilder).toFile());
	}

	public List<UpcCsvDumpDTO> getUpcCsvDump(Long storeNumberId) {
		return upcMasterRepository.getCsvDumpData(
						VendorContactTypeCatalog.CONTACT_TYPE_SALES_REPRESENTATIVE,
						storeNumberId,
						UpcMasterTypeCatalog.PIM_TYPE,
						ProductTypeCatalog.PRODUCT_TYPE_FG).stream()
				.map(UpcCsvDumpDTO::new)
				.collect(Collectors.toList());
	}

	public FileSystemResource getUpcMasterDumpForExport() {
		StringBuilder contentBuilder = new StringBuilder();
		String[] headers = {
				"Item Num",
				"Type",
				"UPC",
				"SKU",
				"Product name",
				"Product Group",
				"Product Category",
				"Product Subcategory",
				"Product Item",
				"Product Type (FG/RM)",
				"Store Section",
				"Brand Owner",
				"Country of Origin",
				"Product Description",
				"Product Image (Yes or No)",
				"Weight",
				"Length",
				"Height",
				"Width",
				"Sales Price (USD)",
				"Tax %",
				"Trading Status",
				"Sold in bulk (Yes or No)",
				"Content per Unit",
				"Content per Unit UOM",
				"Inventory Unit",
				"Shelf Life WH",
				"Shelf Life Shipment",
				"Shelf Life Customer",
				"Planogram Location",
				"Stock min",
				"Lot Num required (True-1/False-0)",
				"Exp Date required (True-1/False-0)",
				"Age Restricted (True-1/False-0)",
				"Return increases inventory (True-1/False-0)",
				"VC Trained (True-1/False-0)",
				"UPC Tax Percentage",
				"Selling channels",
				"Additional Fees"
		};
		String header = Arrays.stream(headers)
				.map(s -> StringUtils.wrap(s, '"'))
				.collect(Collectors.joining(","));

		contentBuilder.append(header)
				.append(System.lineSeparator());

		String results = getUpcMasterDump().stream()
				.map(upcRecord -> String.format(StringUtils.repeat("%s", ",", headers.length),
						StringUtils.wrap(numberToString(upcRecord.getUpcMasterId()), '"'),
						StringUtils.wrap(upcRecord.getUpcMasterType(), '"'),
						StringUtils.wrap(StringUtils.prependIfMissing(upcRecord.getPrincipalUPC(), "'"), '"'),
						StringUtils.wrap(upcRecord.getSku(), '"'),
						StringUtils.wrap(upcRecord.getProductName(), '"'),
						StringUtils.wrap(upcRecord.getProductGroupName(), '"'),
						StringUtils.wrap(upcRecord.getProductCategoryName(), '"'),
						StringUtils.wrap(upcRecord.getProductSubcategoryName(), '"'),
						StringUtils.wrap(upcRecord.getProductItemName(), '"'),
						StringUtils.wrap(upcRecord.getProductTypeName(), '"'),
						StringUtils.wrap(upcRecord.getMainEntryTypeName(), '"'),
						StringUtils.wrap(upcRecord.getBrandOwnerName(), '"'),
						StringUtils.wrap(upcRecord.getCountryOfOriginName(), '"'),
						StringUtils.wrap(upcRecord.getProductDescription(), '"'),
						StringUtils.wrap(Objects.nonNull(upcRecord.getWebsiteImage()) ? "Yes" : "No", '"'),
						StringUtils.wrap(numberToString(upcRecord.getProductWeight()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getProductLength()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getProductHeight()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getProductWidth()), '"'),
						StringUtils.wrap(upcRecord.getStorePrices().stream()
								.map(p -> String.format("%s: %s", p.getStoreName(), p.getSalePrice()))
								.collect(Collectors.joining(" | ")),'"'),
						StringUtils.wrap("",'"'),
						StringUtils.wrap(upcRecord.getUpcMasterStatusDesc(), '"'),
						StringUtils.wrap(upcRecord.isSoldInBulk() ? "Yes" : "No", '"'),
						StringUtils.wrap(numberToString(upcRecord.getContentPerUnit()), '"'),
						StringUtils.wrap(upcRecord.getContentPerUnitUomDesc(), '"'),
						StringUtils.wrap(upcRecord.getInventoryUnitDesc(), '"'),
						StringUtils.wrap(numberToString(upcRecord.getShelfLifeWh()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getShelfLifeShipment()), '"'),
						StringUtils.wrap(numberToString(upcRecord.getShelfLifeCustomer()), '"'),
						StringUtils.wrap(Optional.ofNullable(upcRecord.getPlanogramLocation()).orElse(""), '"'),
						StringUtils.wrap(numberToString(upcRecord.getStockMin()), '"'),
						StringUtils.wrap(upcRecord.isBatchRequired() ? "1" : "0", '"'),
						StringUtils.wrap(upcRecord.isExpirationDateRequired() ? "1" : "0", '"'),
						StringUtils.wrap(upcRecord.isAgeRestricted() ? "1" : "0", '"'),
						StringUtils.wrap(upcRecord.isReturnReducesInventory() ? "1" : "0", '"'),
						StringUtils.wrap(upcRecord.isImageTrained() ? "1" : "0", '"'),
						StringUtils.wrap(numberToString(upcRecord.getTaxPercentage()), '"'),
						StringUtils.wrap(upcRecord.getSellingChannels().stream()
								.filter(UpcSellingChannelDTO::isEnabled)
								.map(UpcSellingChannelDTO::getChannelName)
								.collect(Collectors.joining(" | ")), '"'),
						StringUtils.wrap(upcRecord.getAdditionalFees().stream()
								.map(f -> String.format("%s - %s: %s", f.getStoreName(), f.getAdditionalFee(), f.getPrice()))
								.collect(Collectors.joining(" | ")), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		contentBuilder.append(results);

		String fileName = String.format("upc_master_dump_data_%tF.csv", new Date());
		return new FileSystemResource(getWrittenFilePath(fileName, contentBuilder).toFile());
	}

	public List<UpcMasterDTO> getUpcMasterDump() {
		return upcMasterRepository.getDumpData(UpcMasterTypeCatalog.PIM_TYPE).stream()
				.map(m -> new UpcMasterDTO().parseToDTO(m)
						.setStorePrices(m.getStorePrices().stream()
								.map(sp -> new StorePriceDTO().parseToDTO(sp))
								.collect(Collectors.toUnmodifiableList())))
				.collect(Collectors.toList());
	}

	public FileSystemResource getRecipeCsvDumpForExport() {
		StringBuilder contentBuilder = new StringBuilder();
		String[] headers = {
				"Recipe UPC",
				"Recipe Sku",
				"Recipe Name",
				"Recipe Group",
				"Recipe Category",
				"Recipe Subcategory",
				"Brand",
				"Status (ACTIVE / INACTIVE)",
				"Recipe Description",
				"Content per Unit",
				"Content per Unit UOM",
				"Sales Price (USD)",
				"Tax %",
				"Age Restricted (True-1/False-0)",
				"VC Trained (True-1/False-0)",
				"Temp",
				"Additional Fees"};
		String header = Arrays.stream(headers)
				.map(s -> StringUtils.wrap(s, '"'))
				.collect(Collectors.joining(","));

		contentBuilder.append(header)
				.append(System.lineSeparator());

		String results = getRecipeCsvDump().stream()
				.map(recipeRecord -> String.format(StringUtils.repeat("%s", ",", headers.length),
						StringUtils.wrap(StringUtils.prependIfMissing(recipeRecord.getUpc(), "'"), '"'),
						StringUtils.wrap(recipeRecord.getSku(), '"'),
						StringUtils.wrap(recipeRecord.getProductName(), '"'),
						StringUtils.wrap(recipeRecord.getProductGroup(), '"'),
						StringUtils.wrap(recipeRecord.getProductCategory(), '"'),
						StringUtils.wrap(recipeRecord.getProductSubcategory(), '"'),
						StringUtils.wrap(recipeRecord.getBrand(), '"'),
						StringUtils.wrap(recipeRecord.getStatus(), '"'),
						StringUtils.wrap(recipeRecord.getProductDescription(), '"'),
						StringUtils.wrap(numberToString(recipeRecord.getContentPerUnit()), '"'),
						StringUtils.wrap(recipeRecord.getContentPerUnitUom(), '"'),
						StringUtils.wrap(numberToString(recipeRecord.getSalePrice()), '"'),
						StringUtils.wrap(numberToString(recipeRecord.getTaxPercentage()), '"'),
						StringUtils.wrap(recipeRecord.isAgeRestricted() ? "1" : "0", '"'),
						StringUtils.wrap(recipeRecord.isImageTrained() ? "1" : "0", '"'),
						StringUtils.wrap(recipeRecord.getTemperature(), '"'),
						StringUtils.wrap(recipeRecord.getAdditionalFees().stream()
										.map(f -> String.format("%s - %s: %s", f.getStoreName(), f.getFeeName(), f.getPrice()))
										.collect(Collectors.joining(" | ")), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		contentBuilder.append(results);

		String fileName = String.format("recipe_master_data_%tF.csv", new Date());
		return new FileSystemResource(getWrittenFilePath(fileName, contentBuilder).toFile());
	}

	public List<RecipeCsvDumpDTO> getRecipeCsvDump() {
		return recipeRepository.getRecipeCsvDump();
	}

	public FileSystemResource getRecipeIngredientCsvDumpForExport() {
		StringBuilder contentBuilder = new StringBuilder();
		contentBuilder.append("\"Recipe UPC\",\"Recipe Name\",\"Ingredient UPC\",\"Ingredient Name\",\"Ingredient vendor\",\"Qty used\",\"UOM\",\"Cost\",\"Brand\"")
				.append(System.lineSeparator());

		String results = getRecipeIngredientCsvDump().stream()
				.map(ingredientRecord -> String.format(StringUtils.repeat("%s", ",", 9),
						StringUtils.wrap(StringUtils.prependIfMissing(ingredientRecord.getRecipeUpc(), "'"), '"'),
						StringUtils.wrap(ingredientRecord.getRecipeName(), '"'),
						StringUtils.wrap(StringUtils.prependIfMissing(ingredientRecord.getIngredientUpc(), "'"), '"'),
						StringUtils.wrap(ingredientRecord.getIngredientName(), '"'),
						StringUtils.wrap(ingredientRecord.getIngredientVendor(), '"'),
						StringUtils.wrap(numberToString(ingredientRecord.getQty()), '"'),
						StringUtils.wrap(ingredientRecord.getUom(), '"'),
						StringUtils.wrap(Optional.ofNullable(ingredientRecord.getCost()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(ingredientRecord.getBrand(), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		contentBuilder.append(results);

		String fileName = String.format("recipe_ingredients_data_%tF.csv", new Date());
		return new FileSystemResource(getWrittenFilePath(fileName, contentBuilder).toFile());
	}

	public List<RecipeIngredientCsvDumpDTO> getRecipeIngredientCsvDump() {
		List<RecipeIngredientCsvDumpDTO> csvDump = recipeRepository.getRecipeIngredientCsvDump();
		csvDump.forEach(dto -> recipeService.getIngredientCost(
				dto.getIngredientUpcMasterId(),
				dto.getIngredientProductContentPerUnit(),
				dto.getIngredientProductContentPerUnitUomId(),
				dto.getIngredientUnitId(),
				dto.isTopping()
		).ifPresent(dto::setCost));
		return csvDump;
	}

	public FileSystemResource getRecipeAddOnCsvDumpForExport() {
		StringBuilder contentBuilder = new StringBuilder();
		contentBuilder.append("\"Recipe UPC\",\"Recipe Name\",\"Add on UPC\",\"Add on Name\",\"Vendor\",\"Qty used\",\"UOM\",\"Cost\",\"Selling price\",\"Brand\",\"Status (ACTIVE / INACTIVE)\"")
				.append(System.lineSeparator());

		String results = getRecipeAddOnCsvDump().stream()
				.map(addOnRecord -> String.format(StringUtils.repeat("%s", ",", 11),
						StringUtils.wrap(StringUtils.prependIfMissing(addOnRecord.getRecipeUpc(), "'"), '"'),
						StringUtils.wrap(addOnRecord.getRecipeName(), '"'),
						StringUtils.wrap(StringUtils.prependIfMissing(addOnRecord.getAddOnUpc(), "'"), '"'),
						StringUtils.wrap(addOnRecord.getAddOnName(), '"'),
						StringUtils.wrap(addOnRecord.getAddOnVendor(), '"'),
						StringUtils.wrap(numberToString(addOnRecord.getQty()), '"'),
						StringUtils.wrap(addOnRecord.getUom(), '"'),
						StringUtils.wrap(Optional.ofNullable(addOnRecord.getCost()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(Optional.ofNullable(addOnRecord.getSellingPrice()).map(this::numberToString).orElse(""), '"'),
						StringUtils.wrap(addOnRecord.getBrand(), '"'),
						StringUtils.wrap(addOnRecord.getStatus(), '"')
				))
				.collect(Collectors.joining(System.lineSeparator()));

		contentBuilder.append(results);

		String fileName = String.format("recipe_addons_data_%tF.csv", new Date());
		return new FileSystemResource(getWrittenFilePath(fileName, contentBuilder).toFile());
	}

	public List<RecipeAddOnCsvDumpDTO> getRecipeAddOnCsvDump() {
		List<RecipeAddOnCsvDumpDTO> csvDump = recipeRepository.getRecipeAddOnCsvDump();
		csvDump.forEach(dto -> {
			LoadUpcAddOnDTO upcAddOnDTO = recipeAddonService.loadUpcAddonInformation(dto.getAddOnUpcMasterId());
			Optional.ofNullable(upcAddOnDTO.getCostPerUnit()).ifPresent(dto::setCost);
		});
		return csvDump;
	}

	public PurchaseOrderReportDTO getPurchaseOrderReport(Long storeNumId) {
		return getPurchaseOrderReport(storeNumId, true);
	}

	public PurchaseOrderReportDTO getPurchaseOrderReport(Long storeNumId, boolean fetchDetail) {
		StoreNumberDTO storeNumberDTO = storeNumberService.findById(storeNumId);
		String storeManagers = String.join(",", storeNumberService.getStoreManagerNameList(storeNumId));
		PurchaseOrderReportDTO result = new PurchaseOrderReportDTO(new Date(), storeNumberDTO.getStoreName(), storeManagers);

		result.setAmountOrdersDrafted(Optional.ofNullable(purchaseOrderRepository.getCostTotalForStatus(List.of(PoStatusCatalog.PO_STATUS_DRAFT), storeNumId)).orElse(0d));
		result.setAmountOrdersOrdered(Optional.ofNullable(purchaseOrderRepository.getCostTotalForStatus(List.of(PoStatusCatalog.PO_STATUS_ORDERED), storeNumId)).orElse(0d));
		result.setAmountOrdersPendingApproval(Optional.ofNullable(purchaseOrderRepository.getCostTotalForStatus(List.of(PoStatusCatalog.PO_STATUS_PENDING_AUTHORIZATION), storeNumId)).orElse(0d));
		result.setAmountOrdersReceived(Optional.ofNullable(purchaseOrderRepository.getCostTotalForStatus(List.of(PoStatusCatalog.PO_STATUS_COMPLETED, PoStatusCatalog.PO_STATUS_INCOMPLETE), storeNumId)).orElse(0d));

		result.setOrdersWTD(purchaseOrderRepository.getOrdersWeekToDate(storeNumId));
		result.setOrdersMTD(purchaseOrderRepository.getOrdersMonthToDate(storeNumId));

		if (fetchDetail) {
			List<PurchaseOrderDraftedDTO> ordersDrafted = purchaseOrderRepository.getOrdersDrafted(PoStatusCatalog.PO_STATUS_DRAFT, storeNumId);
			ordersDrafted.forEach(order -> order.setRetailPrice(purchaseOrderRepository.getOrderRetailPrice(order.getPurchaseOrderId())));
			result.setDraftedList(ordersDrafted);

			List<PurchaseOrderOrderedDTO> ordersOrdered = purchaseOrderRepository.getOrdersOrdered(PoStatusCatalog.PO_STATUS_ORDERED, storeNumId);
			ordersOrdered.forEach(order -> {
				order.setRetailPrice(purchaseOrderRepository.getOrderRetailPrice(order.getPurchaseOrderId()));
				order.setDaysPending();
			});
			result.setOrderedList(ordersOrdered);

			List<PurchaseOrderPendingApprovalDTO> ordersPending = purchaseOrderRepository.getOrdersPendingApproval(PoStatusCatalog.PO_STATUS_PENDING_AUTHORIZATION, storeNumId);
			ordersPending.forEach(order -> {
				order.setRetailPrice(purchaseOrderRepository.getOrderRetailPrice(order.getPurchaseOrderId()));
				order.setDaysPending();
			});
			result.setPendingApprovalList(ordersPending);

			List<PurchaseOrderReceptionDTO> receivedItems = purchaseOrderRepository.getReceptionDetails(List.of(PoStatusCatalog.PO_STATUS_COMPLETED, PoStatusCatalog.PO_STATUS_INCOMPLETE), storeNumId);
			result.setReceptionList(receivedItems);
		}
		return result;
	}

	public Page<PurchaseOrderDraftedDTO> getDraftedPurchaseOrders(PurchaseOrderReportRequestDTO request) {
		Page<PurchaseOrderDraftedDTO> ordersDrafted = purchaseOrderRepository.getOrdersDrafted(PoStatusCatalog.PO_STATUS_DRAFT, request.getStoreNumId(), request.createPageable());
		ordersDrafted.forEach(order -> order.setRetailPrice(purchaseOrderRepository.getOrderRetailPrice(order.getPurchaseOrderId())));
		return ordersDrafted;
	}

	public Page<PurchaseOrderPendingApprovalDTO> getPendingPurchaseOrders(PurchaseOrderReportRequestDTO request) {
		Page<PurchaseOrderPendingApprovalDTO> ordersPending = purchaseOrderRepository.getOrdersPendingApproval(PoStatusCatalog.PO_STATUS_PENDING_AUTHORIZATION, request.getStoreNumId(), request.createPageable());
		ordersPending.forEach(order -> {
			order.setRetailPrice(purchaseOrderRepository.getOrderRetailPrice(order.getPurchaseOrderId()));
			order.setDaysPending();
		});
		return ordersPending;
	}

	public Page<PurchaseOrderOrderedDTO> getOrderedPurchaseOrders(PurchaseOrderReportRequestDTO request) {
		Page<PurchaseOrderOrderedDTO> ordersOrdered = purchaseOrderRepository.getOrdersOrdered(PoStatusCatalog.PO_STATUS_ORDERED, request.getStoreNumId(), request.createPageable());
		ordersOrdered.forEach(order -> {
			order.setRetailPrice(purchaseOrderRepository.getOrderRetailPrice(order.getPurchaseOrderId()));
			order.setDaysPending();
		});
		return ordersOrdered;
	}

	public Page<PurchaseOrderReceptionDTO> getPurchaseOrderReception(PurchaseOrderReportRequestDTO request) {
		return purchaseOrderRepository.getReceptionDetails(List.of(PoStatusCatalog.PO_STATUS_COMPLETED, PoStatusCatalog.PO_STATUS_INCOMPLETE), request.getStoreNumId(), request.createPageable());
	}

	private Path getWrittenFilePath(String fileName, StringBuilder contentBuilder) {
		Path path = Paths.get(System.getProperty("java.io.tmpdir"), fileName);
		try {
			Files.writeString(path, contentBuilder.toString());
		} catch (IOException e) {
			log.error("Error while writing file", e);
		}
		return path;
	}

	private String numberToString(Number number) {
		return Objects.isNull(number)? "": String.valueOf(number);
	}
}
